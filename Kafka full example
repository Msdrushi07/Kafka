Perfect 🙌 Let’s build a ready-to-use Spring Boot Kafka project structure that covers:

✅ Producer (publishes messages)

✅ Consumer (processes messages)

✅ Error Handling (retry + DLQ)

✅ DLQ Consumer (logs failed messages)

✅ DLQ Reprocessor (re-sends messages back to main topic)



---

📂 Project Structure (Maven)

spring-kafka-demo/
 ├── src/main/java/com/example/kafka/
 │    ├── config/
 │    │     └── KafkaErrorHandlerConfig.java
 │    ├── consumer/
 │    │     ├── OrderConsumer.java
 │    │     └── DlqConsumer.java
 │    ├── producer/
 │    │     └── OrderProducer.java
 │    ├── reprocessor/
 │    │     └── DlqReprocessor.java
 │    └── SpringKafkaDemoApplication.java
 └── src/main/resources/
      └── application.yml


---

⚙️ application.yml

spring:
  kafka:
    bootstrap-servers: localhost:9092
    consumer:
      group-id: order-group
      auto-offset-reset: earliest
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.springframework.kafka.support.serializer.ErrorHandlingDeserializer
      properties:
        spring.deserializer.value.delegate.class: org.springframework.kafka.support.serializer.JsonDeserializer
        spring.json.trusted.packages: "*"
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer


---

🛠️ KafkaErrorHandlerConfig.java

package com.example.kafka.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.listener.DefaultErrorHandler;
import org.springframework.kafka.listener.DeadLetterPublishingRecoverer;
import org.springframework.util.backoff.FixedBackOff;

@Configuration
public class KafkaErrorHandlerConfig {

    @Bean
    public DefaultErrorHandler errorHandler(KafkaTemplate<Object, Object> template) {
        DeadLetterPublishingRecoverer recoverer =
                new DeadLetterPublishingRecoverer(template); // sends to <topic>.DLT

        // Retry 3 times, 2s apart, then send to DLQ
        FixedBackOff fixedBackOff = new FixedBackOff(2000L, 3);

        return new DefaultErrorHandler(recoverer, fixedBackOff);
    }
}


---


import org.apache.kafka.clients.admin.NewTopic;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class KafkaTopicConfig {

    @Bean
    public NewTopic ordersTopic() {
        return new NewTopic("orders", 3, (short) 1); 
        // 3 partitions, replication factor 1
    }

    @Bean
    public NewTopic ordersDltTopic() {
        return new NewTopic("orders.DLT", 3, (short) 1);
    }
}


---
📨 OrderProducer.java

package com.example.kafka.producer;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Service;

@Service
public class OrderProducer {

    @Autowired
    private KafkaTemplate<String, String> kafkaTemplate;

    public void sendOrder(String order) {
        kafkaTemplate.send("orders", order);
        System.out.println("✅ Sent order: " + order);
    }
}


---

📥 OrderConsumer.java

package com.example.kafka.consumer;

import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.kafka.support.Acknowledgment;
import org.springframework.stereotype.Service;

@Service
public class OrderConsumer {

    @KafkaListener(topics = "orders", groupId = "order-group")
    public void consume(String message, Acknowledgment ack) {
        try {
            System.out.println("Processing order: " + message);

            if (message.contains("fail")) {
                throw new RuntimeException("Simulated failure: " + message);
            }

            ack.acknowledge(); // commit offset only if success
        } catch (Exception e) {
            // ❌ don’t ack → triggers errorHandler (retries + DLQ)
            throw e;
        }
    }
}


---

❌ DlqConsumer.java (Monitor DLQ)

package com.example.kafka.consumer;

import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.stereotype.Service;

@Service
public class DlqConsumer {

    @KafkaListener(topics = "orders.DLT", groupId = "dlq-group")
    public void consumeDlq(String message) {
        System.out.println("🚨 Message moved to DLQ: " + message);
    }
}


---

♻️ DlqReprocessor.java (Re-send from DLQ → Main)

package com.example.kafka.reprocessor;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Service;

@Service
public class DlqReprocessor {

    @Autowired
    private KafkaTemplate<String, String> kafkaTemplate;

    @KafkaListener(topics = "orders.DLT", groupId = "dlq-reprocessor")
    public void reprocess(String message) {
        System.out.println("♻️ Reprocessing DLQ message: " + message);

        try {
            if (message.contains("bad")) {
                System.out.println("⚠️ Skipping permanently bad message: " + message);
                return;
            }

            kafkaTemplate.send("orders", message);
            System.out.println("✅ Resent message to orders: " + message);

        } catch (Exception e) {
            System.err.println("❌ Reprocessing failed: " + e.getMessage());
        }
    }
}


---

🚀 SpringKafkaDemoApplication.java

package com.example.kafka;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class SpringKafkaDemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(SpringKafkaDemoApplication.class, args);
    }
}


---

🔄 How It Works

1. Normal flow →
Producer → orders topic → Consumer processes → Ack on success.


2. Failure flow →
Consumer fails → retried 3 times → message goes to orders.DLT.


3. DLQ monitoring →
DlqConsumer logs failed messages.


4. Reprocessing →
DlqReprocessor listens to DLQ → re-sends valid messages to orders.




---

using command creating topics
# Create main topic
kafka-topics.sh --create --topic orders --partitions 3 --replication-factor 1 --bootstrap-server localhost:9092

# Create DLQ topic
kafka-topics.sh --create --topic orders.DLT --partitions 3 --replication-factor 1 --bootstrap-server localhost:9092



